import * as fs from "fs-extra";
import * as path from "path";
import SwaggerParser from "@apidevtools/swagger-parser";
import Handlebars from "handlebars";
import chalk from "chalk";
import {
  OpenApiSpec,
  ApiEndpoint,
  GeneratorConfig,
  GeneratedFile,
  Schema,
} from "./types";
import {
  pathToTypeName,
  capitalize,
  schemaToTypeScript,
  generateMethodName,
  ensureDir,
} from "./utils";

export class ApiGenerator {
  private config: GeneratorConfig;
  private spec: OpenApiSpec | null = null;
  private endpoints: ApiEndpoint[] = [];
  private schemas: Record<string, Schema> = {};

  constructor(config: GeneratorConfig) {
    this.config = config;
  }

  /**
   * 从文件加载OpenAPI规范
   */
  async loadSpec(specPath: string): Promise<void> {
    try {
      console.log(chalk.blue(`Loading OpenAPI spec from: ${specPath}`));
      this.spec = (await SwaggerParser.parse(specPath)) as OpenApiSpec;
      this.parseEndpoints();
      this.parseSchemas();
      console.log(chalk.green(`✅ Loaded ${this.endpoints.length} endpoints`));
    } catch (error) {
      throw new Error(`Failed to load OpenAPI spec: ${error}`);
    }
  }

  /**
   * 解析API端点
   */
  private parseEndpoints(): void {
    if (!this.spec) return;

    this.endpoints = [];
    Object.entries(this.spec.paths).forEach(([path, pathItem]) => {
      if (!pathItem || typeof pathItem !== "object") return;

      Object.entries(pathItem).forEach(([method, operation]) => {
        if (["get", "post", "put", "delete", "patch"].includes(method)) {
          if (operation && typeof operation === "object") {
            const op = operation as any;
            this.endpoints.push({
              path,
              method: method.toUpperCase(),
              operationId: op.operationId,
              summary: op.summary,
              description: op.description,
              parameters: op.parameters || [],
              requestBody: op.requestBody,
              responses: op.responses || {},
              tags: op.tags || [],
            });
          }
        }
      });
    });
  }

  /**
   * 解析数据模型
   */
  private parseSchemas(): void {
    if (!this.spec?.components?.schemas) return;
    this.schemas = this.spec.components.schemas;
  }

  /**
   * 生成API代码
   */
  async generate(): Promise<GeneratedFile[]> {
    if (!this.spec) {
      throw new Error("No OpenAPI spec loaded");
    }

    console.log(chalk.blue("Generating API code..."));

    const files: GeneratedFile[] = [];

    // 生成类型定义
    files.push(await this.generateTypes());

    // 生成API客户端
    files.push(await this.generateApiClient());

    // 生成HTTP客户端接口
    files.push(await this.generateHttpClient());

    // 生成索引文件
    files.push(await this.generateIndex());

    // 生成npm包配置文件
    files.push(await this.generatePackageJson());
    files.push(await this.generateTsConfig());
    files.push(await this.generateTsupConfig());
    files.push(await this.generateReadme());

    // 写入文件
    await this.writeFiles(files);

    // 构建JavaScript文件
    await this.buildPackage();

    console.log(chalk.green(`✅ Generated ${files.length} files`));
    return files;
  }

  /**
   * 生成类型定义
   */
  private async generateTypes(): Promise<GeneratedFile> {
    const template = `// Auto-generated types from OpenAPI spec
// Do not edit this file manually

{{#each schemas}}
export interface {{@key}} {
{{#each this.properties}}
  {{@key}}{{#unless (isRequired @key ../required)}}?{{/unless}}: {{toTypeScript this}};
{{/each}}
}

{{/each}}

// API Response types
{{#each endpoints}}
export interface {{capitalize method}}{{pathToTypeName path}}Response {
{{#each responses}}
  {{#if (eq @key "200")}}
  data: {{#if content.application/json.schema}}{{toTypeScript content.application/json.schema}}{{else}}any{{/if}};
  {{/if}}
{{/each}}
}

{{#if requestBody}}
export interface {{capitalize method}}{{pathToTypeName path}}Request {
{{#if requestBody.content.application/json.schema}}
  {{toTypeScript requestBody.content.application/json.schema}}
{{else}}
  [key: string]: any;
{{/if}}
}
{{/if}}

{{/each}}`;

    // 注册Handlebars helpers
    Handlebars.registerHelper("toTypeScript", (schema: Schema) => {
      return schemaToTypeScript(schema);
    });

    Handlebars.registerHelper("pathToTypeName", pathToTypeName);
    Handlebars.registerHelper("capitalize", capitalize);
    Handlebars.registerHelper(
      "isRequired",
      (key: string, required: string[]) => {
        return required && required.includes(key);
      }
    );
    Handlebars.registerHelper("eq", (a: any, b: any) => a === b);

    const compiledTemplate = Handlebars.compile(template);
    const content = compiledTemplate({
      schemas: this.schemas,
      endpoints: this.endpoints,
    });

    return {
      path: "src/types.ts",
      content,
    };
  }

  /**
   * 生成API客户端
   */
  private async generateApiClient(): Promise<GeneratedFile> {
    const template = `// Auto-generated API client from OpenAPI spec
// Do not edit this file manually

import { HttpClient } from '{{httpClientImport}}';
import * as Types from './types';

export class ApiClient {
  private httpClient: HttpClient;
  private baseUrl: string;

  constructor(httpClient: HttpClient, baseUrl: string = '{{baseUrl}}') {
    this.httpClient = httpClient;
    this.baseUrl = baseUrl;
  }

{{#each endpoints}}
  /**
   * {{summary}}
   * {{description}}
   */
  async {{generateMethodName method path operationId}}(
{{#if parameters}}
    params: {
{{#each parameters}}
      {{name}}{{#unless required}}?{{/unless}}: {{toTypeScript schema}};
{{/each}}
    },
{{/if}}
{{#if requestBody}}
    data: Types.{{capitalize method}}{{pathToTypeName path}}Request,
{{/if}}
    options?: import('axios').AxiosRequestConfig
  ): Promise<Types.{{capitalize method}}{{pathToTypeName path}}Response> {
    const url = \`\${this.baseUrl}{{path}}\`{{#if parameters}}
      .replace(/\{([^}]+)\}/g, (match, key) => {
        const value = params[key as keyof typeof params];
        return value !== undefined ? String(value) : match;
      }){{/if}};

{{#if (hasQueryParams parameters)}}
    const queryParams = new URLSearchParams();
{{#each parameters}}
{{#if (eq in "query")}}
    if (params.{{name}} !== undefined) {
      queryParams.append('{{name}}', String(params.{{name}}));
    }
{{/if}}
{{/each}}
    const finalUrl = queryParams.toString() ? \`\${url}?\${queryParams}\` : url;
{{else}}
    const finalUrl = url;
{{/if}}

    const response = await this.httpClient.{{toLowerCase method}}(
      finalUrl,
{{#if requestBody}}
      data,
{{/if}}
      {
{{#if (hasHeaderParams parameters)}}
        headers: {
{{#each parameters}}
{{#if (eq in "header")}}
          '{{name}}': params.{{name}},
{{/if}}
{{/each}}
          ...options?.headers
        },
{{/if}}
        ...options
      }
    );

    return { data: response.data };
  }

{{/each}}
}`;

    // 注册更多helpers
    Handlebars.registerHelper("generateMethodName", generateMethodName);
    Handlebars.registerHelper("toLowerCase", (str: string) =>
      str.toLowerCase()
    );
    Handlebars.registerHelper("hasQueryParams", (parameters: any[]) => {
      return parameters && parameters.some((p) => p.in === "query");
    });
    Handlebars.registerHelper("hasHeaderParams", (parameters: any[]) => {
      return parameters && parameters.some((p) => p.in === "header");
    });

    const compiledTemplate = Handlebars.compile(template);
    const baseUrl = this.spec?.servers?.[0]?.url || "";
    const content = compiledTemplate({
      endpoints: this.endpoints,
      baseUrl,
      httpClientImport: this.config.httpClientImport || "./http-client",
    });

    return {
      path: "src/api-client.ts",
      content,
    };
  }

  /**
   * 生成HTTP客户端
   */
  private async generateHttpClient(): Promise<GeneratedFile> {
    const template = `// HTTP Client interface
// Implement this interface with your preferred HTTP library

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export interface HttpClient {
  get(url: string, config?: AxiosRequestConfig): Promise<{ data: any }>;
  post(url: string, data?: any, config?: AxiosRequestConfig): Promise<{ data: any }>;
  put(url: string, data?: any, config?: AxiosRequestConfig): Promise<{ data: any }>;
  delete(url: string, config?: AxiosRequestConfig): Promise<{ data: any }>;
  patch(url: string, data?: any, config?: AxiosRequestConfig): Promise<{ data: any }>;
}

// Axios implementation
export class AxiosHttpClient implements HttpClient {
  private axiosInstance: AxiosInstance;

  constructor(axiosInstance: AxiosInstance) {
    this.axiosInstance = axiosInstance;
  }

  async get(url: string, config?: AxiosRequestConfig): Promise<{ data: any }> {
    const response = await this.axiosInstance.get(url, config);
    return { data: response.data };
  }

  async post(url: string, data?: any, config?: AxiosRequestConfig): Promise<{ data: any }> {
    const response = await this.axiosInstance.post(url, data, config);
    return { data: response.data };
  }

  async put(url: string, data?: any, config?: AxiosRequestConfig): Promise<{ data: any }> {
    const response = await this.axiosInstance.put(url, data, config);
    return { data: response.data };
  }

  async delete(url: string, config?: AxiosRequestConfig): Promise<{ data: any }> {
    const response = await this.axiosInstance.delete(url, config);
    return { data: response.data };
  }

  async patch(url: string, data?: any, config?: AxiosRequestConfig): Promise<{ data: any }> {
    const response = await this.axiosInstance.patch(url, data, config);
    return { data: response.data };
  }

  // 获取axios实例，用于更高级的配置
  getAxiosInstance(): AxiosInstance {
    return this.axiosInstance;
  }
}

// 默认导出
export default AxiosHttpClient;

// 使用示例
/*
import axios from 'axios';
import { AxiosHttpClient } from './http-client';
import { ApiClient } from './api-client';

// 创建axios实例
const axiosInstance = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your-token'
  }
});

// 添加请求拦截器
axiosInstance.interceptors.request.use(
  (config) => {
    // 可以在这里添加认证token等
    console.log('Request:', config);
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 添加响应拦截器
axiosInstance.interceptors.response.use(
  (response) => {
    console.log('Response:', response);
    return response;
  },
  (error) => {
    // 统一错误处理
    if (error.response) {
      console.error('HTTP error:', error.response.status, error.response.data);
    } else if (error.request) {
      console.error('Network error:', error.request);
    } else {
      console.error('Request error:', error.message);
    }
    return Promise.reject(error);
  }
);

// 创建HTTP客户端
const httpClient = new AxiosHttpClient(axiosInstance);

// 创建API客户端
const apiClient = new ApiClient(httpClient);

// 使用API客户端
async function example() {
  try {
    const users = await apiClient.getUsers();
    console.log('Users:', users);
  } catch (error) {
    console.error('Error:', error);
  }
}
*/
`;

    return {
      path: "src/http-client.ts",
      content: template,
    };
  }

  /**
   * 生成package.json
   */
  private async generatePackageJson(): Promise<GeneratedFile> {
    const specTitle = this.spec?.info?.title || "Generated API Client";
    const specVersion = this.spec?.info?.version || "1.0.0";
    const specDescription =
      this.spec?.info?.description ||
      "Auto-generated API client from OpenAPI specification";

    const packageJson = {
      name:
        this.config.packageName ||
        specTitle
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z0-9-]/g, ""),
      version: specVersion,
      description: specDescription,
      main: "dist/index.js",
      module: "dist/index.mjs",
      types: "dist/index.d.ts",
      files: ["dist/**/*", "src/**/*"],
      scripts: {
        build: "tsup",
        dev: "tsup --watch",
        prepublishOnly: "npm run build",
        "build:publish": "npm run build && npm publish",
        "version:patch": "npm version patch --no-git-tag-version",
        "version:minor": "npm version minor --no-git-tag-version",
        "version:major": "npm version major --no-git-tag-version"
      },
      keywords: ["api", "client", "openapi", "swagger", "typescript", "axios"],
      author: "",
      license: "MIT",
      dependencies: {
        axios: "^1.6.0",
        chalk: "^4.1.2",
      },
      devDependencies: {
        "@types/node": "^20.0.0",
        typescript: "^5.0.0",
        tsup: "^8.5.0",
      },
      engines: {
        node: ">=16",
      },
    };

    return {
      path: "package.json",
      content: JSON.stringify(packageJson, null, 2),
    };
  }

  /**
   * 生成tsconfig.json
   */
  private async generateTsConfig(): Promise<GeneratedFile> {
    const tsConfig = {
      compilerOptions: {
        target: "ES2020",
        lib: ["ES2020"],
        module: "CommonJS",
        outDir: "./dist",
        rootDir: "./src",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        declaration: true,
        declarationMap: true,
        sourceMap: true,
        resolveJsonModule: true,
      },
      include: ["src/**/*"],
      exclude: ["node_modules", "dist"],
    };

    return {
      path: "tsconfig.json",
      content: JSON.stringify(tsConfig, null, 2),
    };
  }

  /**
   * 生成tsup.config.ts
   */
  private async generateTsupConfig(): Promise<GeneratedFile> {
    const content = `import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['cjs', 'esm'],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  target: 'node16',
  outDir: 'dist'
});
`;

    return {
      path: "tsup.config.ts",
      content,
    };
  }

  /**
   * 生成README.md
   */
  private async generateReadme(): Promise<GeneratedFile> {
    const specTitle = this.spec?.info?.title || "Generated API Client";
    const specDescription =
      this.spec?.info?.description ||
      "Auto-generated API client from OpenAPI specification";
    const packageName =
      this.config.packageName ||
      specTitle
        .toLowerCase()
        .replace(/\s+/g, "-")
        .replace(/[^a-z0-9-]/g, "");

    const content = `# ${specTitle}

${specDescription}

## Installation

\`\`\`bash
npm install ${packageName}
\`\`\`

## Usage

\`\`\`typescript
import axios from 'axios';
import { AxiosHttpClient, ApiClient } from '${packageName}';

// Create axios instance with your configuration
const axiosInstance = axios.create({
  baseURL: 'https://your-api-base-url.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your-token'
  }
});

// Add interceptors if needed
axiosInstance.interceptors.request.use(
  (config) => {
    // Add auth token, logging, etc.
    return config;
  },
  (error) => Promise.reject(error)
);

axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle errors globally
    console.error('API Error:', error);
    return Promise.reject(error);
  }
);

// Create HTTP client and API client
const httpClient = new AxiosHttpClient(axiosInstance);
const apiClient = new ApiClient(httpClient);

// Use the API client
async function example() {
  try {
    const result = await apiClient.someMethod();
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
  }
}
\`\`\`

## API Reference

This package provides the following exports:

- \`ApiClient\`: Main API client class
- \`AxiosHttpClient\`: HTTP client implementation using axios
- \`HttpClient\`: HTTP client interface
- Type definitions for all API endpoints and data models

## Development

\`\`\`bash
# Install dependencies
npm install

# Build the package
npm run build

# Watch for changes during development
npm run dev
\`\`\`

## License

MIT
`;

    return {
      path: "README.md",
      content,
    };
  }

  /**
   * 生成索引文件
   */
  private async generateIndex(): Promise<GeneratedFile> {
    const content = `// Auto-generated index file
// Do not edit this file manually

export * from './types';
export * from './api-client';
export { ApiClient } from './api-client';
`;

    return {
      path: "src/index.ts",
      content,
    };
  }

  /**
   * 写入文件到磁盘
   */
  private async writeFiles(files: GeneratedFile[]): Promise<void> {
    ensureDir(this.config.outputDir);

    for (const file of files) {
      const fullPath = path.join(this.config.outputDir, file.path);
      ensureDir(path.dirname(fullPath));
      await fs.writeFile(fullPath, file.content, "utf8");
      console.log(chalk.gray(`  ✓ ${file.path}`));
    }
  }

  /**
   * 构建npm包
   */
  private async buildPackage(): Promise<void> {
    const { spawn } = require("child_process");

    console.log(chalk.blue("Installing dependencies..."));

    // 先安装依赖
    await new Promise<void>((resolve, reject) => {
      const installProcess = spawn("npm", ["install"], {
        cwd: this.config.outputDir,
        stdio: "inherit",
      });

      installProcess.on("close", (code: number | null) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Install process exited with code ${code}`));
        }
      });

      installProcess.on("error", (error: Error) => {
        reject(error);
      });
    });

    console.log(chalk.blue("Building package..."));

    // 然后构建
    return new Promise((resolve, reject) => {
      const buildProcess = spawn("npm", ["run", "build"], {
        cwd: this.config.outputDir,
        stdio: "inherit",
      });

      buildProcess.on("close", (code: number | null) => {
        if (code === 0) {
          console.log(chalk.green("✅ Package built successfully"));
          resolve();
        } else {
          reject(new Error(`Build process exited with code ${code}`));
        }
      });

      buildProcess.on("error", (error: Error) => {
        reject(error);
      });
    });
  }
}
